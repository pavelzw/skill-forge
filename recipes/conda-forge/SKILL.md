---
name: conda-forge
description: Performs conda-forge operations. Fixes failing builds by analyzing CI logs, creates new packages via staged-recipes, adds cross-compilation and ARM support to feedstocks, and migrates recipes from v0 to v1 format. Use when working with conda-forge feedstocks, staged-recipes, build failures, recipe migrations, or when the user mentions conda-forge.
license: BSD-3-Clause
compatibility: >-
  Requires gh (GitHub CLI), git, curl, jq, tar, and pixi with
  rattler-build and conda-smithy. Requires network access.
---

# Conda-Forge Skill

First, determine the workflow by checking the current working directory:
- **staged-recipes** repo → you are creating a new feedstock
- **\<name\>-feedstock** repo → you are updating an existing feedstock

## Staged Recipes: Creating New Feedstocks

New packages are submitted via [staged-recipes](https://github.com/conda-forge/staged-recipes). After merge, conda-forge auto-creates a dedicated feedstock.

Fork and branch:
```bash
gh repo fork conda-forge/staged-recipes --clone=true
git switch -c <PACKAGE_NAME>
```

Generate a recipe for Python packages with `pixi exec grayskull pypi --use-v1-format --strict-conda-forge <PACKAGE_NAME>`. For Go or Rust, adapt the templates from [example-recipe-go.md](references/example-recipe-go.md) or [example-recipe-rust.md](references/example-recipe-rust.md). See also [example-recipe-python.md](references/example-recipe-python.md).

Place the recipe in `recipes/<PACKAGE_NAME>/recipe.yaml`.

Recipe rules:
- Use source tarballs with SHA256 checksums (compute with `curl -Ls "<URL>" | sha256sum -`)
- Use SPDX license identifiers and include `license_file`
- Tests are mandatory (at minimum: import test for Python, `--help` for CLI)
- All dependencies must already exist on conda-forge
- Remove any template/placeholder comments

Test locally:
```bash
rattler-build build -r recipes/<PACKAGE_NAME> -m .ci_support/<VARIANT>.yaml
```

For `noarch: python` packages, provide the `python_min` context since staged-recipes doesn't define it:
```bash
rattler-build build -r recipes/<PACKAGE_NAME> -m .ci_support/<VARIANT>.yaml --context python_min=3.10
```

Submit a draft PR. Watch CI until green. Don't mark as ready for review — let the human do that. To skip a platform, add `skip: win` in the `build` section.

For submitting multiple related packages, place each in a separate directory under `recipes/`. The build system resolves dependency order within staged-recipes.

## Existing Feedstock: Updating

Work on `recipe/recipe.yaml`. If you only find a `meta.yaml`, you must convert it to `recipe.yaml` first — see [rattler-build-migration.md](references/rattler-build-migration.md).

### Fork Workflow

conda-forge requires all PRs from forks. Never push directly to `conda-forge/<feedstock>`.

```bash
gh repo fork conda-forge/<FEEDSTOCK> --clone
```

This sets `origin` → your fork, `upstream` → conda-forge repo.

### Fixing Failing Builds

To diagnose a failing CI build:
1. `gh pr view <PR> --repo <OWNER/REPO> --json headRefName,headRepository,statusCheckRollup,url,title`
2. Find checks with `"conclusion": "FAILURE"` and extract the Azure Pipelines `detailsUrl`
3. Extract `buildId` from the URL, then fetch the timeline:
   `curl -s "https://dev.azure.com/conda-forge/feedstock-builds/_apis/build/builds/<BUILD_ID>/timeline?api-version=6.0"`
4. Find failed records and fetch their log URLs
5. Read the error log — understand the root cause before making any changes

Apply the minimal fix needed. Only modify files in the `recipe/` directory.

If the error is not trivial, try to reproduce it locally first. If `rattler-build` fails, it keeps the work directory at `output/bld/rattler-build_.../work` — you can debug with `cd <work> && source build_env.sh`.

### Test Locally

Always test with a variant config that matches your local platform:
```bash
pixi exec rattler-build build --recipe recipe -m .ci_support/<VARIANT>.yaml
```

### Finalize Changes

After all recipe changes, always run:
```bash
pixi exec conda-smithy rerender --no-check-uptodate --commit=auto
pixi exec conda-smithy lint --conda-forge .
```

Commit your recipe changes first, then rerender (which auto-commits if there are changes). Only modify files in the `recipe/` directory — everything else is autogenerated by rerender.

Push to your fork and create a PR to `conda-forge/<FEEDSTOCK>:main`.

## General

Use `pixi exec <tool>` to run tools (rattler-build, conda-smithy, grayskull, feedrattler) without installing them. Use `mktemp -d` for temporary working directories.

### Python Version Pinning (noarch recipes)

For `noarch: python` recipes, use conda-forge's pinning conventions:
- host: `python ${{ python_min }}.*`
- run: `python >=${{ python_min }}`
- tests: `python_version: ${{ python_min }}.*` or `python ${{ python_min }}.*`

If a newer Python minimum is required than conda-forge's default (3.10), override `python_min` in the `context` section of the recipe.

### Common Errors

- **`no candidates were found`**: Wrong dependency name. Use `pixi search <name>` (supports globs like `pixi search 'lib*'`).
- **Import errors in test phase**: Missing runtime dependency → add to `requirements.run`.
- **Compilation failure**: Missing library → add to `requirements.host`.
- **Command not found (exit 127)**: Missing build tool → add to `requirements.build`.

### Key Decisions

- `noarch: python`: Use for pure Python packages with no compiled extensions or platform-specific code.
- `noarch: generic`: Use for packages without any compiled code (e.g., shell-only recipes).
- Build backend: Match `pyproject.toml`'s `[build-system].requires`.
- For cross-compilation details, see [cross-compilation.md](references/cross-compilation.md).

### References

- [Python recipe template](references/example-recipe-python.md)
- [Go recipe template](references/example-recipe-go.md)
- [Rust recipe template](references/example-recipe-rust.md)
- [Cross-compilation and ARM support](references/cross-compilation.md)
- [Recipe migration (v0 → v1)](references/rattler-build-migration.md)
